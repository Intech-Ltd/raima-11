<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:tocPath="Native API|User's Guide" MadCap:InPreviewMode="false" MadCap:PreloadImages="false" MadCap:RuntimeFileType="Topic" MadCap:TargetType="WebHelp" lang="en-us" xml:lang="en-us" class="" MadCap:PathToHelpSystem="../../" MadCap:HelpSystemFileName="Default.xml" MadCap:SearchType="Stem">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Transaction Processing</title>
        <link rel="icon" type="image/png" href="http://docs.raima.com/favicon.png" />
        <link href="../SkinSupport/MadCap.css" rel="stylesheet" />
        <link href="../Resources/TableStyles/ArgsTwoCol.css" rel="stylesheet" />
        <link href="../Resources/Stylesheets/raima.css" rel="stylesheet" />
        <script src="../SkinSupport/MadCapAll.js" type="text/javascript">
        </script>
    </head>
    <body>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkTop" style="display: none;"><a href="../../Default_CSH.htm#UG/Chapter6.htm" style="">Open topic with navigation</a>
        </p>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix">You are here: </span><a class="MCBreadcrumbsLink" href="../dbCore.htm">Native API</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="dbUG.htm">User's Guide</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">Transaction Processing</span>
        </div>
        <h1 class="firstHeading"><a MadCap:generatedBookmark="TOC" name="Transaction_Processing"></a>Transaction Processing</h1>
        <p>This section discusses transaction processing.&#160; Transaction processing is a process by which multiple, related updates are grouped together and then written to the database as a unit. </p>
        <h2 class="Heading2"><a MadCap:generatedBookmark="TOC" name="6.1_Introduction_to_Transaction_Processing"></a><a name="6.1"></a>6.1 Introduction to Transaction Processing </h2>
        <p>Transaction processing is used to maintain the logical consistency of a database by allowing multiple, related updates to be grouped together and then written to the database as a unit. For example, in the TIMS database the entry of a book into the library could involve the creation of up to five records (<code>author</code>, <code>info</code>, <code>text</code>, <code>intersect</code>, <code>key_word</code>) and connections to five sets (<code>author_list</code>, <code>has_published</code>, <code>abstract</code>, <code>info_to_key</code>, <code>key_to_info</code>). If all of these changes were coded as a transaction and a failure occurred before the transaction ended, none of the changes would be in the database. Without transaction processing, the changes would be written to the database only as necessary, and a failure would leave the database in an inconsistent state (for example, it could leave an info record that is not connected to an <code>author</code> record). </p>
        <p>Transaction processing is required to perform any kind of database update. If the database is opened in  exclusive mode, transactions are implicit, and only written to the database as necessary leaving the database susceptible to corruption on a failure. It is best, as a rule, to always begin and end related sets of changes with <code>d_trbegin</code> and <code>d_trend</code> function calls.</p>
        <p class="Notes">Transactions are <i>not </i>intended for use when reading the database. Reading may occur outside of transactions (with read locks or read-only-transactions if in shared mode). A transaction should begin only when an application is fully ready to perform an update to the database. Fully ready, in this case, means that the application should not have to wait for any more information from the user or otherwise during the update. The transaction should go from beginning to end without user interruption. </p>
        <p>The process wherein the changes are written to the database is called the transaction commit. The commit is a safe update performed by the Transactional File Server (TFS).</p>
        <h2 class="Heading2"><a MadCap:generatedBookmark="TOC" name="6.2_Operational_Environment"></a><a name="6.2"></a>6.2 Operational Environment </h2>
        <p>Any <span class="MyVariablesProductShortName">RDM</span> application will be linked together with the <span class="MyVariablesProductShortName">RDM</span> runtime library - a set of functions that perform operations on database pages in a local cache. The actual database (or databases) are maintained under the safe control of one or more Transactional File Servers (TFSs) that are running on a computer that is visible to the application (very possibly the same computer the application is running on).</p>
        <p>Any database page in the runtime's local cache has been requested from the TFS. To have permission to read the page, the application either has exclusive access to the database, or it has performed a read or write lock on the file. </p>
        <p>Any update performed by the application will be encapsulated as a set of changed pages and transferred from the runtime to the TFS as a unit. The TFS is optimized to apply the pages to the database files quickly in a multi-user environment. It is also constructed to perform all page updates as a unit, so that there are never any inconsistencies in a database. It does the database updates in a fully recoverable way, so that transactional changes will be fully present or fully absent even if the TFS loses power and must be restarted.</p>
        <p>Figure 6-1 shows a generalized view of the operational environment.</p>
        <p class="Caption">
            <img src="../Resources/Images/UsersGuide/UG-Fig-6-1_593x414.png" style="width: 593;height: 414;" />
            <br />Fig. 6-1. Operational Environment</p>
        <h2 class="Heading2"><a MadCap:generatedBookmark="TOC" name="6.3_Transaction_Processing_Functions"></a><a name="6.3"></a>6.3 Transaction Processing Functions </h2>
        <p>Ten functions are provided in <span class="MyVariablesProductShortName">RDM</span> to support transaction processing. These are listed in Table 6-1. Function <code>d_trbegin</code> is used to mark the beginning of a transaction. All changes specified after the <code>d_trbegin</code> call are written to the database at the same time, when function <code>d_trend</code> is called to end (or <i>commit</i>) the transaction. If any errors are detected, or if a requested lock is not available after <code>d_trbegin</code> has been called, function <code>d_trabort</code> can be called to abort the transaction. This function will discard any changes that have been made since the beginning of the transaction, ensuring that the state of the database is the same after <code>d_trabort</code> as it was before <code>d_trbegin</code>. </p>
        <table style="width: 100%;caption-side: top;border-collapse: collapse;margin-left: 0;margin-right: auto;mc-table-style: url('../Resources/TableStyles/ArgsTwoCol.css');" class="TableStyle-ArgsTwoCol" cellspacing="0">
            <caption>Table 6-1. Transaction Processing Functions</caption>
            <col style="width: 206px;" class="Column-Column1" />
            <col class="Column-Column2" />
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_trbegin.htm">d_trbegin</a>
                </td>
                <td class="BodyD-Column2-Body1">Begin transaction </td>
            </tr>
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_trprecommit.htm">d_trprecommit</a>
                </td>
                <td class="BodyD-Column2-Body1">Prepare transaction for commit (in 2-phase commit)</td>
            </tr>
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_trend.htm">d_trend</a>
                </td>
                <td class="BodyD-Column2-Body1">End transaction </td>
            </tr>
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_trabort.htm">d_trabort</a> <![CDATA[ ]]></td>
                <td class="BodyD-Column2-Body1">Abort transaction </td>
            </tr>
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_tractive.htm">d_tractive</a>
                </td>
                <td class="BodyD-Column2-Body1">Determine whether a transaction is active</td>
            </tr>
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_trmark.htm">d_trmark</a>
                </td>
                <td class="BodyD-Column2-Body1">Set a transaction mark</td>
            </tr>
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_trdeletemark.htm">d_trdeletemark</a>
                </td>
                <td class="BodyD-Column2-Body1">Remove a transaction mark</td>
            </tr>
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_trrollback.htm">d_trrollback</a>
                </td>
                <td class="BodyD-Column2-Body1">Roll a transaction back to a mark</td>
            </tr>
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_trrobegin.htm">d_trrobegin</a>
                </td>
                <td class="BodyD-Column2-Body1">Begin a read-only transaction</td>
            </tr>
            <tr class="Body-Body1">
                <td style="font-family: monospace;" class="BodyE-Column1-Body1"><a href="../RM/api/d_trroend.htm">d_trroend</a>
                </td>
                <td class="BodyD-Column2-Body1">End a read-only transaction</td>
            </tr>
        </table>
        <p>Function <code>d_trbegin</code> is called to notify the <span class="MyVariablesProductShortName">RDM</span> runtime of the start of a new transaction. Transactions cannot be nested within a task. If <code>d_trbegin</code> is called from within a task with active transaction, error code <code>S_TRACTIVE</code> will be returned. </p>
        <p>Function <code>d_trprecommit</code> will prepare the transaction log file to a point where a trivial "go-ahead" will finalize, or commit, the transaction. It is expected that an external transaction monitor, or coordinator, is controlling this transaction together with transactions from external data sources to perform a 2-phase commit. Otherwise, there is no advantage to using this function. After this function is called, and before <code>d_trend</code> or <code>d_trabort</code> are called, no reads or updates are permitted on the database(s) in the same task.</p>
        <p>Function <code>d_trend</code> completes a transaction by committing all changes to the database. </p>
        <p>Function <code>d_trabort</code> <![CDATA[ ]]>discards all changes performed since the <code>d_trbegin</code> call, and frees all locks, including keep locks.</p>
        <p>Function <code>d_tractive</code> checks if a transaction is active.  Since <span class="MyVariablesProductShortName">RDM</span> does not allow nested transactions, the application might call <code>d_tractive</code> within subfunctions to determine whether to begin and end a transaction.</p>
        <p>Function <code>d_trmark</code> saves a position in a current transaction.  Later, your application can roll back (via <code>d_trrollback</code>) to this point in the transaction to discard portions of a transaction without terminating the transaction or discarding locks.</p>
        <p>Function <code>d_trdeletemark</code> removes a mark from a transaction.  Deleting marks when they are no longer needed can save memory because for each page modified since the mark was applied, a copy of the original page is kept to rollback to if necessary.</p>
        <p>Function <code>d_trrollback</code> removes any changes after a set mark (or the beginning of the transaction).</p>
        <p>Function <code>d_trrobegin</code> begins a read-only transaction.  Changes made by other users will not appear to the user calling <code>d_trrobegin</code>.</p>
        <p>Function <code>d_trroend</code> ends a read-only transaction.</p>
        <h2 class="Heading2"><a MadCap:generatedBookmark="TOC" name="6.4_Locking_Rules"></a><a name="6.42"></a>6.4 Locking Rules</h2>
        <p>Locks are required to prevent database reads that contain partial changes from other users, and to prevent updates on the same data by different users.</p>
        <p><b>Read locks</b> allow safe reading of data. Read locks may be requested whether or not a transaction is active. Any number of users may hold read locks on the same data.</p>
        <p><b>Write locks</b> allow data to be updated by preventing any other updates until the transaction performing the update has completed. For this reason, write locks may only be requested while a transaction is active. Only one user may hold a write lock on the same set of data at a time.</p>
        <p>Normally, all locks are freed (both read and write locks) at the end of a transaction. If it is necessary for a lock to be retained after the transaction, it can be marked as a "<b>keep lock</b>" (see <code><a href="../RM/api/d_lock.htm">d_lock</a></code>). If the original lock was a write lock, then if the keep request was issued during the transaction, it will be retained after the <code>d_trend</code> call as a read lock. If the original lock was a read lock, it will remain a read lock and not be freed. Keep locks allow cached database pages to remain cached and readable after the transaction ends. This can decrease concurrency by preventing other transactions from beginning, but increase the performance of the task holding the locks. As with lock upgrades (below), this may be fine in systems with infrequent transactions.</p>
        <p><b>Lock upgrades</b> are simply requests to change read locks into write locks, and therefore must occur within a transaction. An upgrade is necessary when data has been read (normally before the transaction has begun), and updates are based on the read data. If a read lock is freed and re-obtained, it is possible that the read data has changed. Re-reading may be a source of inefficiency, especially in systems where updates are possible but infrequent. An upgrade request may be denied, because another task also held the same read lock and has issued an upgrade request. Only one upgrade can be granted, and the loser must discard all data read during the read lock, assuming that it is now being changed by the other task. A denied upgrade request should result in a transaction abort, and restarting the data collection required for the transaction.</p>
        <p><b><a name="kanchor3"></a>Read-only-transactions</b> allow safe reading of unlocked data by creating a virtual version (a snapshot at that point in time) of the database. A read-only-transaction begins and ends with a pair of function calls (<code>d_trrobegin</code>, <code>d_trroend</code>). When using read-only-transactions, locking and normal transactions are not permitted. Read-only-transactions should be short because they may cause an accumulation of cache pages within the TFS.</p>
        <h2><a MadCap:generatedBookmark="TOC" name="6.5_Transaction_Processing"></a><a name="6.4"></a>6.5 Transaction Processing </h2>
        <p> It is necessary for a single transaction to guarantee that either all changes are applied, or no changes are applied (all updates performed in a transaction are considered an <i>atomic </i>operation). The following list shows the sequence of function calls to be made by an application, along with the underlying action performed by <span class="MyVariablesProductShortName">RDM</span>. </p>
        <table style="caption-side: top;border-left-style: solid;border-left-width: 1px;border-left-color: #c0c0c0;border-right-style: solid;border-right-width: 1px;border-right-color: #c0c0c0;border-top-style: solid;border-top-width: 1px;border-top-color: #c0c0c0;border-bottom-style: solid;border-bottom-width: 1px;border-bottom-color: #c0c0c0;border-collapse: collapse;margin-left: 0;margin-right: auto;">
            <caption>Table 6-2. Actions of Transaction Processing Functions</caption>
            <col style="width: 144px;" />
            <col />
            <tr>
                <th>
                    <p>Function </p>
                </th>
                <th>
                    <p>Action </p>
                </th>
            </tr>
            <tr>
                <td><code>d_trbegin</code> <![CDATA[ ]]></td>
                <td>The "active transaction" state begins. </td>
            </tr>
            <tr>
                <td><code>d_lock</code> <![CDATA[ ]]></td>
                <td>A group lock request is issued. All locks are granted or denied as a unit. A group lock is recommended over a series of <code>d_reclock</code> and <code>d_setlock</code> calls to avoid deadlock.* </td>
            </tr>
            <tr>
                <td style="font-weight: normal;">transaction&#160;body </td>
                <td>Here, a series of function calls to modify the database are made. Modified pages are stored in the local cache. If the cache is not large enough to hold all modified pages, the cache will be expanded.</td>
            </tr>
            <tr>
                <td style="font-weight: normal;">errors?</td>
                <td>Updates can be thrown away and locks released by issuing a <code>d_trabort</code> call. This is normally only necessary if an error is detected during the updating process. If the transaction is aborted, <code>d_trend</code> should not be called.</td>
            </tr>
            <tr>
                <td><code>d_trend</code> <![CDATA[ ]]></td>
                <td>During this call, the commit is made to the database.  During a <code>d_trend</code>, the following sequence occurs: <ol><li value="1">Modified database pages are written to a transaction log file.</li><li value="2">The log file is "synced" (completely written to disk, not just cached).</li><li value="3">The log file is sent to the TFS.</li><li value="4">Upon receipt of the log file, the TFS&#160;will give the runtime permission to proceed. This is considered the actual commit point. Any failure prior to this point will result in no commit of the changes.</li><li value="5">All file locks are freed, including keep locks.</li></ol></td>
            </tr>
        </table>
        <p class="Notes">* Deadlock occurs in a multi-user environment only. </p>
        <p>The number of pages required to store database updates cannot be entirely predicted. When an operational environment has a limited amount of memory available for caching, it will be necessary to make sure that no transaction exceeds the limits. The best way to do this is to write transactions such that they have a maximum number of updates, then run the transaction enough times to be able to predict its maximum cache requirements.</p>
        <p>A transaction should always encompass a set of related changes which if not performed together, leave the database in a logically inconsistent state. However, bulk loading or streaming of data should always have size or count limits after which one transaction is ended and another one begun. This ensures safe storage of the data but keeps the size of the transactions to a statistically controllable limit.</p>
        <p>If a transaction is aborted, the modified pages in the page buffers are cleared. </p>
        <p>The function <code>d_setpages</code> is used to inform the runtime how many pages it should allocate for the cache. This is a starting point, and the cache will automatically expand if necessary. The first parameter to <code>d_setpages</code> is the number of pages to use. The second parameter is ignored (it was used in earlier versions of <span class="MyVariablesProductShortName">RDM</span>).</p><pre xml:space="preserve">d_setpages(dbpgs, ixpgs, task) </pre>
        <h2><a MadCap:generatedBookmark="TOC" name="6.6_Two-Phased_Commits"></a><a name="6.6"></a>6.6 <a name="kanchor4"></a>Two-Phased Commits</h2>
        <p>When <span class="MyVariablesProductShortName">RDM</span> is used within a part of a bigger system, it may be necessary to coordinate <span class="MyVariablesProductShortName">RDM</span> transactions with the transactions of other database systems. The overall system, which may include several computers, processes and DBMS's, may need to ensure that transactional consistency exists at the system level, where either all DBMS's commit their transactions, or none do.</p>
        <p>The two-phased commit protocol was defined as a method to increase the assurance that the system-wide commit is all-or-nothing. It will not be defined here, but information about it may be easily found.</p>
        <p>The <span class="MyVariablesProductShortName">RDM</span> application that exists as a <i>cohort</i> in the system must receive orders from an external <i>coordinator</i>. The cohort's responsibility is fairly simple. When requested by the coordinator to prepare to commit, the transaction should be finalized and enter into a waiting state where a trivial action will be required for the final commit. The normal <span class="MyVariablesProductShortName">RDM</span> <![CDATA[ ]]><code>d_trend</code> function will fully commit the transaction in the one call. This may require a number of steps that are potentially time consuming or risky (relatively speaking, most computers, power systems and networks are very reliable!). The <code>d_trprecommit</code> call will perform all of the time consuming and risky steps without performing the final commit. After a <code>d_trprecommit</code>, the <code>d_trend</code> call will be fast and trivial. The two-phased commit coordinator takes advantage of this by putting all cohorts into the precommit state prior to telling all of them to commit. Conversely, if any of them fail to precommit, then the remaining transactions are all told to abort. The <span class="MyVariablesProductShortName">RDM</span> <![CDATA[ ]]><code>d_trprecommit</code> may also be followed by a <code>d_trabort</code>, in which case all of the prepared updates will be discarded.</p>
        <p>Between the <code>d_trprecommit</code> call and the <code>d_trend</code> or <code>d_trabort</code>, no reading or writing of the database is allowed, although other kinds of processing is not prevented. The program holding a transaction in a precommitted state must be ready to quickly respond when the coordinator issues the final commit or abort command.</p>
        <h2 class="Heading2"><a MadCap:generatedBookmark="TOC" name="6.7_Database_Safety"></a><a name="6.5"></a>6.7 Database Safety</h2>
        <p>Data is stored in a database for multiple reasons, a primary one being <i>safety</i>. Given the potential points of failure in any application, the database management system should take the responsibility for:</p>
        <ul>
            <li value="1">Performing controlled, atomic updates to the database files.</li>
            <li value="2">Indicating to application programs when updates are committed.</li>
            <li value="3">Ensuring that every change that has been reported as committed will remain committed after a system crash.</li>
            <li value="4">Providing mechanisms for disaster recovery for crashes involving more than software errors or power outage.</li>
        </ul>
        <p class="Heading">Controlled, Atomic Updates</p>
        <p>A single transaction is encapsulated into a transaction log file. The entire log file is given to the TFS to be committed. Once the TFS is in control of this log file, it guarantees that the changes will be kept, and will let the runtime continue processing. The TFS will keep this log file until the updated pages are written to the database files and the database files have been fully written to disk.</p>
        <p class="Heading">Commit Notification</p>
        <p>The <code>d_trend</code> function submits the log file to the TFS (among other things), and then waits for the TFS to return. If a "success" code is received from the TFS, then the application can proceed with the knowledge that the updates are committed and safe.</p>
        <p class="Heading">Durability</p>
        <p>Once the <code>d_trend</code> function has returned with S_OKAY, a non-catastrophic failure will not result in lost data. If the failure is the TFS, when the TFS restarts, it will immediately complete any commits that may not have been completed before the failure. Because the committed updates are represented as a set of page contents, it is safe to apply the log file contents multiple times. All log files submitted to the TFS are ordered, and if at any time they should be reapplied to the database files, they will be reapplied in the same order.</p>
        <p class="Heading">Catastrophic Failures</p>
        <p>In the database world, a catastrophic error is a physical crash or breakage of the media storing the database(s). Other points of failure can be repaired without losing data. The mechanisms provided by <span class="MyVariablesProductShortName">RDM</span> to recover from media loss are <i>mirroring</i> and <i>hot backup</i>.</p>
        <ul>
            <li value="1">Mirroring can be initiated from another computer to create an exact copy of a database (a "mirror"). This copy of the database can be used if the original is lost.</li>
            <li value="2">Hot backup can be performed by copying all database files and log files to another medium. Recovery of lost data can be accomplished by copying the files into their proper location under a TFS (perhaps on a new computer, or a new disk drive).</li>
        </ul>
        <hr MadCap:conditions="Default.ScreenOnly" width="100%" size="0" align="center" />
        <p MadCap:conditions="Default.ScreenOnly" style="font-size: 8pt;"><span class="MyVariablesCopyright">Copyright Â© 2012, Raima Inc. All rights reserved.</span>
        </p>
        <script type="text/javascript" src="../SkinSupport/MadCapBodyEnd.js">
        </script>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkBottom" style="display: none;"><a href="../../Default_CSH.htm#UG/Chapter6.htm" style="">Open topic with navigation</a>
        </p>
    </body>
</html>