<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:tocPath="Native API|User's Guide" MadCap:InPreviewMode="false" MadCap:PreloadImages="false" MadCap:RuntimeFileType="Topic" MadCap:TargetType="WebHelp" lang="en-us" xml:lang="en-us" class="" MadCap:PathToHelpSystem="../../" MadCap:HelpSystemFileName="Default.xml" MadCap:SearchType="Stem">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Database Concepts</title>
        <link rel="icon" type="image/png" href="http://docs.raima.com/favicon.png" />
        <link href="../SkinSupport/MadCap.css" rel="stylesheet" />
        <link href="../Resources/Stylesheets/raima.css" rel="stylesheet" />
        <script src="../SkinSupport/MadCapAll.js">
        </script>
    </head>
    <body>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkTop" style="display: none;"><a href="../../Default_CSH.htm#UG/Chapter2.htm" style="">Open topic with navigation</a>
        </p>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix">You are here: </span><a class="MCBreadcrumbsLink" href="../dbCore.htm">Native API</a><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="dbUG.htm">User's Guide</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">Database Concepts</span>
        </div>
        <h1 class="firstHeading"><a MadCap:generatedBookmark="TOC" name="Database_Concepts"></a>Database Concepts</h1>
        <h2><a MadCap:generatedBookmark="TOC" name="2.1_Introduction_..20"></a>2.1 Introduction </h2>
        <p>This section presents the basic database concepts of the <span class="MyVariablesProductShortName">RDM</span> system. The database terms used in this manual are defined in <a href="#2.2">Definitions</a>. The network database model, which forms the basis of the <span class="MyVariablesProductShortName">RDM</span> system, is described in <a href="#2.3">The Network Database Model</a>.&#160; <a href="#2.4">Other Database Models</a>, describes the hierarchical and relational database models. <a href="#2.5">Advantages of the Combined Model</a> describes the advantages of the network model over the relational database model. Specific elements of an <span class="MyVariablesProductShortName">RDM</span> database are described in the final section. </p>
        <p>To use <span class="MyVariablesProductShortName">RDM</span> productively, you need to understand <span class="MyVariablesProductShortName">RDM</span> database concepts. This section's purpose is to provide sufficient information for a database novice to use <span class="MyVariablesProductShortName">RDM</span> effectively. As part of our efforts to familiarize you with database concepts, we have provided a Glossary of database terms. </p>
        <h2><a MadCap:generatedBookmark="TOC" name="2.2_Definitions"></a><a name="2.2"></a>2.2 Definitions </h2>
        <p>The basic unit of information in a database is a <i>field</i>. A field (or <i>data field</i>) is an item of data with attributes such as name, type (for example, a character or an integer), and length. Examples of fields are employee name, date of birth, social security number, inventory item code, and serial number. Other database systems or books may use other terms (such as <i>attribute</i>, or <i>entity</i>) for <i>field</i>. In relational terminology, the term <i>column</i> is used.</p>
        <p>A <i>record type</i> is a named collection of related fields, which are stored and accessed as a unit. In relational terminology, <i>table</i> is used instead of record type. For example, a record named <b>check</b> in a checking account database may have the following fields: </p><pre>date
check number 
paid to 
amount </pre>
        <p>Each <i>occurrence</i> (or <i>instance</i>) of a <b>check</b> record in the database contains a value for each of these fields. In a relational database, an occurrence is called a <i>row</i> in a table. The definition of a record (made up by its fields) is called the <i>record type</i> and is similar to C structures. </p>
        <p>All occurrences of a particular record type are stored in an operating system file. Files are the primary physical storage units of database organization. A database, therefore, is a collection of related files. </p>
        <p>A <i>key</i> is a field through which rapid or sorted access to a record is possible. In the <b>check</b> record, you might define <b>check number</b> as a key field, to allow quick retrieval of a <b>check</b> record occurrence through specification of a check number. </p>
        <p>An index is a file containing only keys. It is synonymously referred to as a key file. The index to this manual demonstrates the features of a key file: the individual subject entries in the index are the "keys," while the page where the subject is discussed is analogous to the associated "records." You can find the page that discusses a desired subject more quickly by using the index than by reading through each page. And, because the keys are sorted in the index, you can quickly find a specific key. Key files are similar, except the computer does the sorting and look-ups for you. To maintain its key files, <span class="MyVariablesProductShortName">RDM</span> uses either the B-tree indexing method or a hash indexing method.</p>
        <p>In a key scan operation (B-tree index only), the keys in an index are read in the order they appear. Key scans are used to produce sorted listings of records and for fast search operations requiring inspection of a large number of record occurrences (for example, retrieving all checks entered between two dates). </p>
        <p>Data relationships often exist between record types. For example, the checking account database may include budget categories. A second record type named <b>budget</b> could be defined with the following data fields: </p><pre>budget code (a key field)
category description 
monthly allocation 
balance </pre>
        <p>To associate a particular budget category with each <b>check</b> record, we add a <b>budget code</b> field to the <b>check</b> record type, forming a relationship between the <b>budget</b> record and the <b>check</b> record. Whenever a check is entered, the related <b>budget</b> record is located via the budget code, and the balance for that budget is updated by the amount specified in the <b>check</b> record. </p>
        <p>The schema is the conceptual definition of the content and organization of a database. A schema will include the definitions of all record types, with their fields and keys.  In <span class="MyVariablesProductShortName">RDM</span> (and most other DBMSs) a Database Definition Language, or DDL, specifies the schema. An <span class="MyVariablesProductShortName">RDM</span> DDL specification for the checking account database is shown below. The specifics of the actual DDL statements are explained in the <a href="Chapter4.htm">Database Design</a> section.</p><pre>database ckngacct {
    data file "chkng.dat" contains budget, check;
    key file  "chkng.key" contains code, check_no;

    record budget {
        key char  code[6];
            char  cat_desc[48];
            float allocation;
            float balance;
    }
    record check {
        key int32_t check_no;
            int32_t check_date;
            char    bud_code[6];
            char    paid_to[48];
            float   amount;
    }
}</pre>
        <p>A data model (or database model) is a conceptual representation of inter-record relationships. The relational database model establishes and maintains inter-record relationships through common data fields. For example, in the checking account example a common data field, <b>budget code</b> (<i>code</i> in the <b>budget</b> record, and <i>bud_code</i> in the <b>check</b> record), establishes the relationship between the <b>budget</b> record and the <b>check</b> record. </p>
        <p>Other database models, in particular the network database model, establish inter-record relationships directly, through physical links between the related records, rather than through common data fields. These models are discussed in the following sections. Since <span class="MyVariablesProductShortName">RDM</span> supports both the relational and the network database models, you can combine the features of these models to meet the needs of your particular application. </p>
        <h2><a MadCap:generatedBookmark="TOC" name="2.3_The_Network_Database_Model"></a><a name="2.3"></a>2.3 The Network Database Model </h2>
        <p>In the <i>network database model</i>, the relationships between record types are explicitly defined and directly maintained through <i>sets</i>. A set defines a one-to-many relationship between two record types. Examples of sets are: </p>
        <blockquote>
            <p><i>one</i> baseball league has <i>many</i> teams </p>
            <p><i>one</i> baseball team has <i>many</i> players </p>
        </blockquote>
        <p>Sets are implemented with linked lists of pointers to the record locations of the set members and owners. The result is a network of interconnected records. </p>
        <p>Figure 2-1 illustrates the set relationships for the baseball example. The boxes represent instances of the <b>league</b>, <b>team</b>, and <b>player</b> record types. The arrows represent the links that connect the related records. </p>
        <p class="Caption">
            <img src="../Resources/Images/UsersGuide/02000002.jpg" />&#160; <br />Fig. 2-1. Example of Set Relationships</p>
        <p>Schema diagrams are used to illustrate graphically the inter-record relationships of the database design. Figure 2-2 shows the schema diagram for the baseball example. In this diagram (and in all other schema diagrams in this manual), the boxes represent record types and the arrows represent set types. The <b>league_team</b> set forms a one-to-many relationship between the <b>league</b> record type (called the owner of set <b>league_team</b>) and the team record type (called the member of set <b>league_team</b>). The <b>team_player</b> set forms a one-to-many relationship between the <b>team</b> record type and the <b>player</b> record type. </p>
        <p class="Caption">
            <img src="../Resources/Images/UsersGuide/02000003.jpg" />
            <br />Fig. 2-2. Example of a Schema Diagram</p>
        <p>In the checking account example discussed earlier, the relationship between the <b>budget</b> and <b>check</b> record types could be specified using a set called <b>transactions</b>, defining a one-to-many relationship between a <b>budget</b> record (owner) and the <b>check</b> records (members) written against a particular budget category. In this case, the <b>bud_code</b> field in the <b>check</b> record would not be defined in the <b>check</b> record type, as it is redundant. The <span class="MyVariablesProductShortName">RDM</span> DDL would be modified as follows: </p><pre xml:space="preserve">database ckngacct {
    data file "chkng.dat" contains budget, check;
    key  file "chkng.key" contains code, check_no;

    record budget {
        key char  code[6];
            char  cat_desc[48];
            float allocation;
            float balance;
    }
    record check {
        key int32_t check_no;
            int32_t check_date;
            char    paid_to[48];
            float   amount;
    }
    set transactions {
        order  last;
        owner  budget;
        member check;
    }
}</pre>
        <p>Any given record type can be the owner of any number of different sets and also a member of any number of different sets. Thus, network structures like that shown in Figure 2-3 are valid. </p>
        <p class="Caption">
            <img src="../Resources/Images/UsersGuide/02000004.jpg" class="img_1" />
            <br />Fig. 2-3. Example of a Network Structure</p>
        <p>Notice that records of type E may own other records of type E. Record type C is a member of two sets (A and B) and itself owns two sets (D and E). Records also can own other records through multiple sets, as in the case of B owning E. All these are legitimate constructs in <span class="MyVariablesProductShortName">RDM</span>. </p>
        <h2><a MadCap:generatedBookmark="TOC" name="2.4_Other_Database_Models"></a><a name="2.4"></a>2.4 Other Database Models </h2>
        <p>Two other major database models are the hierarchical and relational models. These are described below. </p>
        <h3 class="Heading3"><a MadCap:generatedBookmark="TOC" name="2.4.1_The_Hierarchical_Database_Model"></a>2.4.1 The Hierarchical Database Model </h3>
        <p>In the hierarchical database model (a subset of the network model) a record type is allowed to be a member of only one set. Record types can still, however, own more than one set. The owner is called the parent and the member is called the child. </p>
        <p>As in the network model, sets are implemented through linked lists. Figure 2-4 shows an example of a hierarchical schema structure. </p>
        <p class="Caption">
            <img src="../Resources/Images/UsersGuide/02000005.jpg" />
            <br />Fig. 2-4. Example of a Hierarchical Structure</p>
        <h3><a MadCap:generatedBookmark="TOC" name="2.4.2_The_Relational_Database_Model"></a>2.4.2 The Relational Database Model </h3>
        <p>The relational database model views the database as a set of two-dimensional tables (or relations). The <i>columns</i>  of a table correspond to data <i>fields</i>, and the <i>rows</i> of the table correspond to record <i>occurrences</i>. This tabular view of a database is particularly easy to manipulate with standard relational database operations, which are based on mathematical set theory. </p>
        <p>In the relational model, relationships between tables are usually established through common data fields. Recall from the initial checking account example that the relationship between the <b>budget</b> and <b>check</b> records was formed by including in the <b>check</b> record a <b>budget code</b> field to identify the budget category. Where the budget code in a check row matches the budget code in a budget row, the two rows are related. Relationships can also be established based on other comparisons, such as "less than."</p>
        <p>The principal distinction between the relational and network models is that in the relational model, relationships are formed through common data fields between the related record types, while in the network model those relationships are defined directly. </p>
        <p>Note that it is possible to transform databases from relational to network and from network to relational. </p>
        <h2><a MadCap:generatedBookmark="TOC" name="2.5_Advantages_of_the_Combined_Model"></a><a name="2.5"></a>2.5 Advantages of the Combined Model </h2>
        <p>Relational model database systems have been extremely popular, primarily because the simplicity of the underlying data model makes them easy to use. Relational query languages also allow questions to be asked that may not have been anticipated when the database schema was designed. With the network model, the primary benefits are better performance, reduced storage requirements, and greater assurance of data integrity. Consider the diagram in Figure 2-5. </p>
        <p class="Caption">
            <img src="../Resources/Images/UsersGuide/02000006.jpg" />
            <br />Fig. 2-5. Relational DBMS Overhead</p>
        <p>This diagram shows two tables that are related through a common data field, C. Note that C must be defined in both tables and that an index must exist in order to access the related table 2 occurrences. Contrast this with the corresponding network model diagram in Figure 2-6. </p>
        <p class="Caption">
            <img src="../Resources/Images/UsersGuide/02000007.jpg" />
            <br />Fig. 2-6. Network DBMS Overhead</p>
        <p>The network model eliminates data redundancy by relating the two record types directly, without requiring the duplicate field and index file. Moreover, the related record is accessed directly with one database read operation, where the relational model forces you to read first an index and then the related record. </p>
        <p>For those situations where an index is more efficient, <span class="MyVariablesProductShortName">RDM</span> provides you with that option. With <span class="MyVariablesProductShortName">RDM</span>, network access and indexed access are independent methods, so you can combine them to suit the needs of your particular application. Combining these technologies gives you maximum database design flexibility. </p>
        <h2 class="Heading2"><a MadCap:generatedBookmark="TOC" name="2.6_Access_Methods_in_RDM"></a>2.6 Access Methods in <span class="MyVariablesProductShortName">RDM</span> <![CDATA[ ]]></h2>
        <p>We have already discussed two access methods available in <span class="MyVariablesProductShortName">RDM</span>: indexes and sets. A third method is called <i>sequential access</i>. All three methods can be used together for navigating and searching in a database. Each has its own ways of establishing and changing a position in the database. The methods are nearly orthogonal, meaning that the use of one will not disrupt the use of the others. The one value they share is the <i>current record</i>, which points to the record in the database that has been found most recently. The current record is the default object for many of the <span class="MyVariablesProductShortName">RDM</span> functions. All three access methods set the current record. </p>
        <p>The <i>indexed</i> method allows you to find a record occurrence by supplying a key. The key can be an exact match, in which case you are positioned directly on a record, or a near match, which will position you just before the record containing a key value higher in the collating sequence. You can also position yourself to the first or last keys of a given key type, regardless of their values. Once at a position, you can move to the previous or next key in the collating sequence. The keys are maintained and navigated in the order maintained in the index, regardless of the physical order of the records to which they point. </p>
        <p>The <i>set</i> method allows you to move through set connections in various directions. You can move from the owner of a set instance to the first or last member of the set. From a set member, you can move to the next or previous member record, or to the owner record. During the navigation of sets, positions are established on a per-set basis: the <i>current owner</i> and <i>current member</i> is indicated for each set type that has been used. If defined, a <i><span class="MCTextPopup"><a href="javascript:void(0);" class="MCTextPopupSpot_0" onclick="FMCTextPopup( event, this ); return false;">system record<img style="border: none;margin-left: 5px;" src="../SkinSupport/ExpandingClosed.gif" MadCap:altsrc="../SkinSupport/ExpandingOpen.gif" onload="if ( typeof( FMCPreloadImage ) == 'function' ) { FMCPreloadImage( '../SkinSupport/ExpandingOpen.gif' ); }" class="MCExpandingIcon" /></a><span class="MCTextPopupBody_0" style="display: none; ">A special record type used to define the "top" record in a network database. There is only one occurrence of the system record in a database. It is defined by naming "system" as a set owner in one or more set definitions in the DDL. When a database is opened, the system record, if it exists, is set as the current owner of all sets for which it is named as owner. It may not be a set member.</span></span></i> can be used as the entry point into a database. When the database is opened, the system record is the current owner of all sets owned by the  in the schema.</p>
        <p>The basic sequential method allows you to find the first, last, next, or previous physical instance of a given record type. <span class="MyVariablesProductShortName">RDM</span> does not allow the programmer to insert records at specific physical positions in a file. Their insertion is normally at the end of a file, but this is not guaranteed if you are using the delete chain (see <a href="../RM/ChapterINI.htm#DCHAINUSE">DCHAINUSE</a>). The sequential method is useful when you are searching all records of a given type, but do not care about the order. </p>
        <p>A second sequential method, called <i>circular</i>, allows you to sequentially scan records in the order in which they were inserted (see below). A circular table is given a maximum size in the schema, and when it attains that size, every new record insertion will result in the oldest record being dropped out of the table.</p>
        <h2 class="Heading2"><a MadCap:generatedBookmark="TOC" name="2.7_Elements_of_an_RDM_Database"></a><a name="2.7"></a>2.7 Elements of an <span class="MyVariablesProductShortName">RDM</span> Database </h2>
        <p>An <span class="MyVariablesProductShortName">RDM</span> database consists of: </p>
        <ul>
            <li style="font-family: sans-serif;" value="1">A dictionary, which stores information describing the content and organization of the database, which may be stored in a file, or compiled into an application program,</li>
            <li style="font-family: sans-serif;" value="2">Data files, which contain occurrences of one or more record types,</li>
            <li style="font-family: sans-serif;" value="3">Key files, which contain an index for one or more key fields, and</li>
            <li style="font-family: sans-serif;" value="4">Vardata files, which contain data belonging to one or more variable length fields.</li>
        </ul>
        <p>Records contain data fields, key fields, and set linkages (which are transparent to the user). They can be accessed through set navigation (that is, traversing through the linked lists associated with specific sets), through key fields (using a fast look-up of the index), sequentially, or through a combination of all three methods. </p>
        <p>Details relating to these elements are fully discussed in <a href="Chapter4.htm">Database Design</a> and <a href="Chapter5.htm">Database Manipulation</a> sections. </p>
        <h2 MadCap:conditions=""><a MadCap:generatedBookmark="TOC" name="2.8_In-Memory_Databases"></a><a name="kanchor1"></a>2.8 In-Memory Databases</h2>
        <p MadCap:conditions=""><span class="MyVariablesProductShortName">RDM</span> supports storage of databases in memory, instead of files. The database contents have the same logical structure, whether stored in memory or in files. Thus the division of the database into data files, key files and vardata files applies to in-memory databases as well as disk-based databases.          <![CDATA[
]]></p>
        <p MadCap:conditions="">The database dictionary, which is normally stored in a file created by <code>ddlp</code>, can now be placed in a static structure in the application program, avoiding the need for any files at all in an <span class="MyVariablesProductShortName">RDM</span> application. </p>
        <p MadCap:conditions="">Database files can also be read from disk when the database is opened and then maintained in memory while the application is running. When the database is closed the contents of the memory can then either be discarded (database files defined as "read") or written back to disk (database files defined as "persistent").
</p>
        <h2><a MadCap:generatedBookmark="TOC" name="2.9_Circular_Tables"></a>2.9 Circular Tables</h2>
        <p>A record type, or table, can now be defined as "circular". With circular tables, when the table becomes full <span class="MyVariablesProductShortName">RDM</span> will still allow new record instances to be created. The new record instances will overwrite existing ones, starting with the oldest. <span class="MyVariablesProductShortName">RDM</span> does not allow explicit deletion of record instances in a circular table.</p>
        <p>The definition of a circular table includes a size limit. This provides a useful way of allocating a fixed amount of storage space for storing the most recent instances of a particular record type. For example, this may be useful in storing event data that is being generated rapidly, where only the most recent data is relevant. Circular tables remove the risk that incoming data may fail to be stored due to lack of space, while avoiding the need for the application to delete obsolete data.</p>
        <hr MadCap:conditions="Default.ScreenOnly" width="100%" size="0" align="center" />
        <p MadCap:conditions="Default.ScreenOnly" style="font-size: 8pt;"><span class="MyVariablesCopyright">Copyright © 2012, Raima Inc. All rights reserved.</span>
        </p>
        <script type="text/javascript" src="../SkinSupport/MadCapBodyEnd.js">
        </script>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkBottom" style="display: none;"><a href="../../Default_CSH.htm#UG/Chapter2.htm" style="">Open topic with navigation</a>
        </p>
    </body>
</html>