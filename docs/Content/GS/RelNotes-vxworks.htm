<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:tocPath="Installation Guide and Release Notes|Release Notes" MadCap:InPreviewMode="false" MadCap:PreloadImages="false" MadCap:RuntimeFileType="Topic" MadCap:TargetType="WebHelp" lang="en-us" xml:lang="en-us" class="" MadCap:PathToHelpSystem="../../" MadCap:HelpSystemFileName="Default.xml" MadCap:SearchType="Stem">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Wind River VxWorks Platform Release Notes</title>
        <link rel="icon" type="image/png" href="http://docs.raima.com/favicon.png" />
        <link href="../SkinSupport/MadCap.css" rel="stylesheet" />
        <link href="../Resources/Stylesheets/raima.css" rel="stylesheet" />
        <script src="../SkinSupport/MadCapAll.js" type="text/javascript">
        </script>
    </head>
    <body>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkTop" style="display: none;"><a href="../../Default_CSH.htm#GS/RelNotes-vxworks.htm" style="">Open topic with navigation</a>
        </p>
        <div class="MCBreadcrumbsBox_0"><span class="MCBreadcrumbsPrefix">You are here: </span><span class="MCBreadcrumbsSelf">Installation Guide and Release Notes</span><span class="MCBreadcrumbsDivider"> &gt; </span><a class="MCBreadcrumbsLink" href="RelNotes.htm">Release Notes</a><span class="MCBreadcrumbsDivider"> &gt; </span><span class="MCBreadcrumbs">Wind River VxWorks Platform Release Notes</span>
        </div>
        <h2 class="newpage">Wind River VxWorks Platform Release Notes</h2>
        <h3>Introduction</h3>
        <p>These instructions are for RDM targeting VxWorks 6.x using downloadables that can be downloaded to a VxWorks kernel. This section explains:</p>
        <ul>
            <li value="1"><a href="#Overview">Overview of VxWorks</a>
            </li>
            <li value="2"><a href="#How">The Transactional File Server under VxWorks</a>
            </li>
            <li value="3"><a href="#How2">Task Priorities</a>
            </li>
            <li value="4"><a href="#How4">How to Compile a VxWorks Kernel for RDM</a>
            </li>
            <li value="5"><a href="#How3">How to Install &amp; Compile RDM for VxWorks</a><a href="#How3">&#160;</a>
            </li>
            <li value="6"><a href="#How5">How to Develop an Application for VxWorks using RDM</a>
            </li>
        </ul>
        <h3><a name="Overview"></a>Overview of VxWorks</h3>
        <p>VxWorks kernel modules does not use ordinary executables as most other operating systems. &#160;They instead use relocatable files which can either be .o-files or .a-files. These relocatable files can either be compiled into the kernel or loaded during run time on a running target. The VxWorks loader is really an advanced linker which are able to link in relocatable files at run time. &#160;Relocatable files in general is files that again can be used as input to ld. &#160;These relocatable files must fulfill some important requirements to be loadable as a kernel module under VxWorks:</p>
        <ul>
            <li value="1">The C-library must not be linked in</li>
            <li value="2">Startup-code must not be linked in</li>
            <li value="3">Unresolved symbols in these relocatable files must either be entry-points into VxWorks, entry-points into libraries already loaded or entry-points which are not used during execution.</li>
            <li value="4">No PIC should be used.</li>
        </ul>
        <p>The GNU Toolkit can be used to compile something which meets the above requirements. &#160;To prevent linking against the C-library we use the option "<code>-nostdlib</code>". &#160;To prevent ld from trying to produce an executable and instead produce a relocatable option "<code>-r</code>" can be used.</p>
        <p>Applications can be prepared for execution on the target in principally two ways:</p>
        <ul>
            <li value="1">Compile the application without linking against any library. On the target we load RDM libraries, and then the application.</li>
            <li value="2">Compile the application by linking against our libraries. On the target we load our linked application.</li>
        </ul>
        <p>With the first approach it is possible to load more than one application which uses the same library. The second approach does not have that capability, but it is more convenient by only having to load one module.</p>
        <h3><a name="How"></a>The Transactional File Server Under VxWorks</h3>
        <p>For the TFS API as explained in the <a href="../TFS/Chapter1.htm#14.2">TFS Configuration Guide</a>, there are three configurations:</p>
        <ul>
            <li value="1"><a href="../TFS/Chapter2.htm#2.2">Remote TFS (tfsr)</a>
            </li>
            <li value="2"><a href="../TFS/Chapter2.htm#2.3">Direct-linked TFS (tfst)</a>
            </li>
            <li value="3"><a href="../TFS/Chapter2.htm#2.4">Standalone TFS (tfss)</a>
            </li>
        </ul>
        <p>An application can only use one of these configurations at a given
time, which can be selected at runtime through <code>d_tfsinit</code>.</p>
        <p>A TFS daemon under Unix or a TFS service under Windows is a
specialized application which is not applicable to VxWorks kernel
modules.  VxWorks kernel module applications will instead use a built
in TFS.  A VxWorks application will therefore not be able to access a
local TFS and a remote TFS at the same time.  Other hosts can however
access a TFS on this host.</p>
        <h3><a name="How2"></a>Task Priorities</h3>
        <p>RDM is implemented using one or more tasks under VxWorks.
The number of tasks required depends on how RDM is
configured.

The TFSt configuration has one server task (assuming threading has
been specified) and one check pointer task. &#160;The server task will
initialize the TFS, spawn a connection task for each client, and do
some cleanup upon termination.

Each of these tasks can run at the same or different priorities. &#160;A
higher priority task (low numerical value under VxWorks) is guaranteed
to run before a low priority task (high numerical value under VxWorks),
as long as the high priority task is ready to run. &#160;</p>
        <p>Assigning
priorities is crucial for proper operation of the system.
Incorrectly assigned priorities can lead to starvation, exhausting of
resources, or unresponsive systems. &#160;There is also often a trade off
between these objectives which makes this task even more difficult.

For a system consisting of one producer and one consumer, where we
optimize for the responsiveness of the producer, the producer is assigned
a higher priority than the consumer.&#160;This may, under certain
conditions, exhaust resources and starve the consumer.</p>
        <p>If we want to
minimize the amount of resources used and protect against starvation, the consumer is instead
assigned a higher priority than the producer.
This will however make the producer less responsive. &#160;There is often a trade off between the responsiveness of a system, resource
allocation, and starvation. &#160;Exactly how this plays out will depend on the
application, and how priorities should be assigned will depend on your
requirements.
The priorities of RDM tasks are in general set by giving
priority to the consumer. This minimizes the amount of resources used,
but may result in less responsive systems.</p>
        <p class="Notes">Priorities are
defined in <code>include/pspvxworks.h</code>. &#160;You may change these priorities
based on your requirements.</p>
        <h3 class="newpage"><a name="How3"></a>How to Compile a VxWorks Kernel for RDM</h3>
        <p>This section describes how to build a VxWorks image using WorkBench
targeting VxWorks 6.9 or later, and assumes a basic working knowledge of
the Wind River host development environment.</p>
        <p>Create a new VxWorks Image Project by:</p>
        <blockquote>
            <p>Select <code>"File" -&gt; "New" -&gt; "VxWorks Image Project"</code>.</p>
            <p>Enter a project name and click Next

   </p>
            <p>Select a BSP and "Address mode" that matches your hardware and the
    "gnu" as the "Tool chain" and click Finish

</p>
        </blockquote>
        <p>Open the Application Development perspective.  In the Project Explorer
click the triangle to the left of the project name and double click
"Kernel Configuration" and make sure to include the following
components and set maximum number of files as 1023:

  </p><pre xml:space="preserve">  "Kernel Configuration"
     -&gt; "operating system components"
        -&gt; "POSIX components"
           -&gt; "POSIX ftruncate" INCLUDE_POSIX_FTRUNC
        -&gt; "IO system Components"
           -&gt; "IO Subsystem Components"
              -&gt; "Basic IO System
                 -&gt; "max # open files in the system" NUM_FILES 1023
           -&gt; "dosFs File System Components"
              -&gt; "dosfs File System Main Module"
                 -&gt; "Default Max Open Files" DOSFS_DEFAULT_MAX_FILES 1023
           -&gt; "File System and Disk Utilities" INCLUDE_DISK_UTIL</pre>
        <p>If you are using the RDM C++ API you will also need to include C++ compiler support:</p><pre xml:space="preserve">  "Kernel Configuration"
     -&gt; "C++ components"
         -&gt; "C++ compiler support routines" INCLUDE_CPLUS_LANG
     -&gt; "development tool components"
         -&gt; "symbol table components"
             -&gt; C++ symbol demangler" INCLUDE_CPLUS_DEMANGLER</pre>
        <p>For our QA we have also included these components:</p><pre xml:space="preserve">  "Kernel Configuration"
     -&gt; Network Components
        -&gt; "Layer 5 (Application) Components"
           -&gt; "FTP Components"
              -&gt; "FTP Client" INCLUDE_IPFTPC
           -&gt; "PING Components"
              -&gt; "PING client" INCLUDE_PING
           -&gt; "TELNET Components"
              -&gt; "TELNET Server" INCLUDE_IPTELNETS
     -&gt; "development tool components"
        -&gt; "kernel shell components"
           -&gt; "kernel shell startup script" INCLUDE_STARTUP_SCRIPT
        -&gt; "WDB agent components"
           -&gt; "WDB agent services"
              -&gt; "WDB is always enabled" INCLUDE_WDB_ALWAYS_ENABLED</pre>
        <p>In addition you will need to set up a file system.  Before building your kernel you must set up the kernel with a
        file system. Please see the next section for how to set up a DOS
        RAM file system. When finished, select the project in the
        Project Explorer and select <code>"Project" -&gt; "Build Project"</code>.   The VxWorks image will show up as
<code>default/vxWorks</code> under the location for the project.</p>
        <h4 class="newpage"><a name="DOS"></a>DOS (FAT) RAM&#160;File Systems</h4>
        <p>A dosFS RAM file system is needed unless you use some other hardware
with a dosFS, such as a flash memory card. When using a target device with a memory card using the DOS (FAT) filesystem, the following step is unnecessary. If you are using the simulator, we would strongly
encourage you to use a dosFS RAM file system instead of the host file
system.

</p>
        <p>In the Project Explorer, double click "<code>usrAppInit.c</code>" to edit this
file. &#160;Include the following code for creating an dosFS RAM file system:</p><pre xml:space="preserve">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;dosFsLib.h&gt;
#include &lt;xbdPartition.h&gt;
#include &lt;xbdRamDisk.h&gt;
#define BLOCKSIZE 512

struct {
   char *devname;
   unsigned int disksize;
} disk[]= {
   {"/ram", 0x8000000}, /* 128 MB */
   {NULL, 0}
};

STATUS dosfsSetup (void) {
   STATUS error;
   device_t xbd;
   unsigned int i;
   for (i= 0; disk[i].devname; i++) {
      /* Create a RAM disk. */
      xbd = xbdRamDiskDevCreate (BLOCKSIZE, &#160;disk[i].disksize, 0, disk[i].devname);
      if (xbd == NULLDEV) {
         printf("Failed to create RAM disk. errno = 0x%x\n", errno);
         return (ERROR);
      }
      /*
       * Format the RAM disk for DOSFS.
       */
      error = dosFsVolFormat (disk[i].devname, DOS_OPT_BLANK, 0);
      if (error != OK) {
         printf("Failed to format RAM disk. errno = 0x%x\n", errno);
         return (ERROR);
      }
      printf ("%s now ready for use.\n", disk[i].devname);
   }
   return (OK);
}

/******************************************************************************
 *
 * usrAppInit - initialize the users application
 */

void usrAppInit (void) {
#ifdef	USER_APPL_INIT
   USER_APPL_INIT;		/* for backwards compatibility */
#endif

   /* add application specific code here */
   dosfsSetup ();
}</pre>
        <p class="Notes">There is a known issue on ARM platforms with the handling of de-normalized floating point values. It is advised not to use a floating point value in an index on ARM based platforms.</p>
        <h3 class="newpage"><a name="How4"></a>How to Install &amp; Compile RDM for VxWorks</h3>
        <h4>Installation</h4>
        <p>Please see the <a href="../IG/Hosted.htm">Hosted Platform Install Guide</a> for detailed installation steps.</p>
        <h4 class="newpage"><a name="Configur"></a>Configure</h4>
        <p class="Notes">&#160;WorkBench does not
give you the option of specifying a current working directory. &#160;It
must always be set programmatically unless you are using a target
shell. See the following section to specify this before compiling:</p>
        <p>In the <code>sysmake/k_vx6x86.mak</code> (x86) file, configure the following line to the desired startup directory:</p><pre xml:space="preserve">PSP_STARTUP_HOOK = -DPSP_STARTUP_HOOK="chdir(\"/ram\");"</pre>
        <p>Other specific build settings can also be customized as needed in these files.</p>
        <h4 class="newpage">Compile</h4>
        <ol>
            <li value="1">Startup the Wind River development environment shell</li>
        </ol>
        <p class="ParamIndent">On Unix: </p>
        <p class="ParamDesc">From the top level of the install directory:</p>
        <blockquote>
            <blockquote><pre xml:space="preserve">{path to Wind River install}/wrenv.sh -p vxworks-6.9</pre>
            </blockquote>
        </blockquote>
        <p class="ParamIndent">On Windows:</p>
        <p class="ParamDesc">Open a newVxWorks 6.9 Development shell from the Wind River start menu</p>
        <ol MadCap:continue="true">
            <li value="2">Next, set up the <span class="MyVariablesProductShortName">RDM</span> environment<br /></li>
        </ol>
        <p class="Param">Please specify the desired architecture for VxWorks as follows :</p>
        <p class="ParamDesc">vx6x86 - Intel x86 Processor</p>
        <p class="ParamIndent">On Unix:</p>
        <blockquote>
            <blockquote><pre xml:space="preserve">. ./rdm.sh -{architecture}</pre>
                <p class="Notes">Note, this command must be <strong>sourced</strong>, by prepending it with ". " as shown above</p>
            </blockquote>
        </blockquote>
        <p class="ParamIndent">On Windows:</p>
        <blockquote>
            <blockquote><pre xml:space="preserve">rdm.bat {architecture}</pre>
            </blockquote>
        </blockquote>
        <ol MadCap:continue="true">
            <li value="3">Run the build command</li>
        </ol>
        <blockquote>
            <blockquote><pre xml:space="preserve">k</pre>
            </blockquote>
        </blockquote>
        <h3 class="newpage"><a name="How5"></a>How to Develop an Application for VxWorks using RDM</h3>
        <p>RDM examples written in C uses the <code>PSP_STARTUP_EXAMPLE</code> macro.
The argument to this macro need to match the name of a named main
function as shown below. &#160;The tims example uses this macro as follows:</p><pre xml:space="preserve">int32_t EXTERNAL_FCN tims_main(
   int32_t &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;argc,
   const char *const *argv)
{
   ...
}
PSP_STARTUP_EXAMPLE(tims)</pre>
        <p>The <code>PSP_STARTUP_EXAMPLE</code> macro as used above expands to a function with
the following signature (this signature matches the requirements for
sp and <code>taskSpawn</code>):</p><pre xml:space="preserve">int32_t tims(
   int32_t a1,
   int32_t a2,
   int32_t a3,
   int32_t a4,
   int32_t a5,
   int32_t a6,
   int32_t a7,
   int32_t a8,
   int32_t a9,
   int32_t a10);</pre>
        <p>Use this function as the entry point to the <code>tims</code> example. &#160;The <code>tims</code>example does not take any arguments. &#160;You should therefor pass in 0
as the first and only argument to this function.</p><pre xml:space="preserve">tims 0</pre>
        <p>This function takes care of initializing the RDM platform
support layer (<code>psp_init()</code>), builds up the argument list for the named
main function, calls the named main function, and terminates the
platform support layer (<code>psp_term()</code>).

Examples and tools that do take arguments should be passed in as
strings. &#160;One string for each parameter. You always need to pass in 0
after the last argument unless all ten arguments are specified.

You also have the option of compiling in a hook for the
<code>PSP_STARTUP_EXAMPLE</code>. &#160;We usually compile in a hook like this:</p><pre xml:space="preserve">-DPSP_STARTUP_HOOK="chdir(\"/ram\");</pre>
        <p>This will change the current working directory. "/ram" is typically used with a RAM file system; you may substitute this with your desired working directory. This is most
convenient when we launch this from WorkBench. &#160;WorkBench does not
give you the option of specifying a current working directory. &#160;It
must always be set programmatically unless you are using a target
shell.

</p>
        <h3>Using the RDM C++ API on VxWorks</h3>
        <p>Use of the RDM C++ API require a few extra steps when used with
VxWorks.  The final C++ objects needs to be munched before loading
them onto the VxWorks target.  Please see the Wind River Documentation
for detail:</p><pre xml:space="preserve">   Wind River Documentation
   -&gt; VxWorks, 6.9
      -&gt; VxWorks Kernel Shell User's Guide, 6.9
          -&gt; Kernel Object-Module Loader
             -&gt; Loading C++ Modules into the Kernel</pre>
        <p>We use a custom shell script for munching our C++ objects:</p><pre xml:space="preserve">    #!/bin/sh
    # munch.sh

    if [ $# != 1 ] ; then
       echo "$0: Illegal number of parameters ($#)"
       exit 1
    fi
    
    if [ X$ARCH = X ] ; then
        echo "$0: Environment variable ARCH not set"
        exit 1
    fi
    
    if [ X$WIND_BASE = X ] ; then
        echo "$0: Environment variable WIND_BASE not set"
        exit 1
    fi
    
    if [ ! -f "$1" ]; then
        echo "$0: File '$1' does not exist"
        exit 1;
    fi
    
    if [ "$1.out" -nt "$1" ]; then
        echo "$0: Warning: No munching needed since '$1.out' is newer than '$1'"
        exit 0
    fi
    
    nm$ARCH $1 |wtxtcl $WIND_BASE/host/resource/hutils/tcl/munch.tcl -c $ARCH &gt;ctdt$$.c
    cc$ARCH -g -O0 -r -nostdlib -Wl,-X "-T$WIND_BASE/target/h/tool/gnu/ldscripts/link.OUT" ctdt$$.c "$1" -o "$1.out"
    rm -f ctdt$$.c ctdt$$.o
</pre>
        <p>Use this script from a VxWorks development shell.  The script takes one
argument, file name of the object to be munched and assumes one
environment variable, ARCH, the architecture.  The script produces one
output file based on the input file name with extension '<code>.out</code>'.</p>
        <p>For a Pentium architecture we munch our libraries as follows:
</p><pre xml:space="preserve">$ ARCH=pentium munch.sh cppbomExample</pre>
        <p>This will produce one output file, <code>cppbomExample.out</code>.  Load, run, and
unload this object on the VxWorks target as follows (here we assume
that the vx6x86 RDM folder on the development host is available
through '<code>ftp:</code>' and we have chosen to spawn a task instead of running
it directly from the target shell):
</p><pre xml:space="preserve">-&gt; ldid= ld (1, 0, "ftp:bin/cppbomExample.out")
ldid = 0x3626010: value = 57163792 = 0x3684010
-&gt; taskSpawn "cppbom", 120, 0, 0x4000, cppbom, "-l", "3", "-m", "3", 0
value = 199246312 = 0xbe041e8
CPP Network Model BOM Benchmark Example
<span class="MyVariablesProductName">Raima Database Manager</span>  <![CDATA[ ]]><span class="MyVariablesReleaseVersion">11.0.0</span> Build <span class="MyVariablesBuild">412</span>  <![CDATA[ ]]><span class="MyVariablesVersionDate">[2-15-2012]</span>  <![CDATA[ ]]><span class="MyVariablesURLHome">http://www.raima.com</span><br />Copyright (c) <span class="MyVariablesCopyrightYear">2012</span>  <![CDATA[ ]]><span class="MyVariablesCompanyName">Raima Inc.</span>, All rights reserved.

Document Root: /ram/
Create BOM with 3 levels and 3 members per level
    Building bill of materials
        millisecs: 0
    rolling up cost
        total rolled up cost = 27
        millisecs: 16
-&gt; unld ldid
value = 0 = 0x0
-&gt;</pre>
        <hr MadCap:conditions="Default.ScreenOnly" width="100%" size="0" align="center" />
        <p MadCap:conditions="Default.ScreenOnly" style="font-size: 8pt;"><span class="MyVariablesCopyright">Copyright © 2012, Raima Inc. All rights reserved.</span>
        </p>
        <script type="text/javascript" src="../SkinSupport/MadCapBodyEnd.js">
        </script>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkBottom" style="display: none;"><a href="../../Default_CSH.htm#GS/RelNotes-vxworks.htm" style="">Open topic with navigation</a>
        </p>
    </body>
</html>